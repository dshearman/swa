## Looking for Trends

Looking for Trends in Facebook reach or Twitter mentions can relate to important business problems.
For example,

* Is our online profile increasing or decreasing.
* Are our competitors profiles increasing or decreasing.
* What are the *trending* topics? Twitter do this.
* Did some event have an impact? (Advertising campaign, product release?)

Focussing on Twitter, the first two relate to looking at the number of mentions over time. The third, Twitter already do, and we will look at how. The fourth, event impact, will be looked at in another lecture.

# Twitter Trending Topics

## Twitter Trending Topics

\begin{columns}
  \begin{column}{0.6\textwidth}
Twitter produce a list of Trending topics. These can be made location specific eg. Australian trends. But the basic 
technique for determining them is the same.

Taken from a presentation by 
[Kostas Tsioutsioulikis, Twitter](https://www.youtube.com/watch?v=duHxpSTmwW0)
  \end{column}
  \begin{column}{0.4\textwidth}
\includegraphics[width=0.8\linewidth]{TwitterTrends.pdf}
\end{column}
\end{columns}

## What is a Topic?

Firstly, though we need to decide what is a topic?

* Can be a simple commonly occurring word or phrase
    * Of course, we would ignore stop words etc.
    * There is a problem, becuase there are a large number of possibilities.
* Another possibility is to use a dictionary.
    * Extract common phrases from  other sources eg. wikipedia, usernames, sources specific to an application.
  
Given a (large) list of topics, what is trending?

## What is Trending? Simple counting.

* Count the number of times a topic occurs (in Australia?) in a fixed time period.
* Look at the ratio of current frequency to the past.
* High ratios, mean a trend

Problems

* What about a *new* topic? Past frequency will zero (or close)
* What about overall frequency? Is an increase from 10 to 20 the same as 10,000 to 20,000?
* What is a high ratio?

## Trends using a $\chi^2$-test

Alternative is to establish an *expected* frequency using historical data, and compare the observed frequency (current)
to the expected frequency (past). We can compare observed to expected using a $\chi^2$ statistic

$$\chi^2 = \sum \frac{(O-E)^2}{E}$$

For a chi-squared test we need to consider a fixed number of tweets and compare those containing various topics.

Topic | A | B | C 
-- | -- | -- | --
Num. tweets Current| 201 | 323 | 241 
Num. tweets Past| 181 | 299 | 254

## Trends using a $\chi^2$-test

There are problems with this approach, not least, some tweets may contain multiple topics.
So Twitter use a simplified version.

Num Tweets | Tweet contains topic | Tweet doesn't contain topic
-- | -- | -- 
Current| 201 | 323 
Past| 181 | 299 

(This is equivalent to Proportion test, but Twitter uses $\chi^2$)

## Trends using a $\chi^2$-test

Procedure; 

* collect $N$ tweets from past, and $N$ tweets from today. (In fact $N$ needn't be the same)
* See which past tweets contains topic of interest, say $X$ of them.
* See which of current tweets contains topic of interest say $Y$ of them.
* Calculate $\chi^2$ statistic (treats past as *expected*)

$$
\chi^2 = \frac{(Y-X)^2}{X} + \frac{((N-Y) - (N-X))^2}{(N-X)}
$$

$$
\chi^2 = \frac{(Y-X)^2}{X} + \frac{(X-Y)^2}{(N-X)}
$$

If $N >> X ,Y$ then the second term can be ignored.

## Trends using a $\chi^2$-test

Twitter could use the $p$-value from the $\chi^2$ test to say if a topic *is* trending.

_Null hypothesis_ is that its not.

But more usual to do ranking based on the statistic.

What if the Expected count is zero. Simply add 1.

# Issues with Twitter's method

## Issues with Twitter's method

As a statistician, I have some issues with Twitter's method. 

Firstly, their expected counts are based on an historical *sample*. Secondly, they treat the low count case in pretty ad-hoc ways.

## Issues with Twitter's method

An alternative would be a two-sample proportion test.

* Proportion of Tweets with topic before is estimated as $X/N$.
* Proportion of Tweets with topic after is estimated as $Y/N$.
* Compare proportions
    * $z$-test if $N$ is large and proportions not too small
    * Binomial test otherwise.

Twitter may have chosen their approach for computational reasons, and it may not matter.

# Other methods for Trends --- Simple Linear Regression

## Regression

Another possible way to think about trends in Twitter counts is via a model for each topic.

For example, if $Y_t$ is the count of tweets on a topic in time period $t$ we _might_ model this as

$$ Y_t = \alpha + \beta t + \varepsilon$$

Where $\alpha$ represents the tweet count at time zero, $\beta$ is the slope --- the change in count per unit time.

The term $\varepsilon$ represents an additive random noise element. 

__This is an example of Simple Linear Regression__

## Simple Linear Regression in one slide.

\begin{align*}
y=\alpha+\beta x + \varepsilon && \varepsilon \sim N(0,\sigma^2) \text{ independent}\\
SS_X = \sum (x_i-\bar{x})^2 && SS_{XY} = \sum (y_i-\bar{y})(x_i-\bar{x})\\
\hat{\beta} = SS_{XY}/SS_X && \hat{\alpha} = \bar{y} - \hat{\beta} \bar{x}\\
RSS = \sum (y_i - \hat{y}_i)^2 && s^2 = RSS/(n-2)\\
\frac{\hat{\beta}-\beta}{s/\sqrt{SS_X}} \sim t_{n-2}
\end{align*}

## Simple Linear Regression for Twitter data?

For tweets there are problems. 

* Counts are rarely Normally distributed, and their variance $\sigma^2$ is not constant.
* Also the errors might occur in runs ie be over the line in a group then under the line. This means they are NOT independent.
* The trend may not be very linear.

The first can often be fixed with a transformation --- typically a log or square root. 
Taking logs or square roots usually has the effect of making count data more Normally distributed and stabilising the variance.

In fact, for Poisson counts, the square root is the _Variance Stabilising Transformation_ and doesn't have an issue with zero counts.

## Variance Stabilising Transformation

```{r, echo=FALSE, dev="pdf", fig.width=4, fig.height=2.5, fig.cap="Variance of 10000 Poisson RV (right=square root) Scales are not equal"}
lambda = exp(seq(-1, 3, length=10))
v1 = sapply(lambda, function(x) var(rpois(10000,x)))
v2 = sapply(lambda, function(x) var(sqrt(rpois(10000,x))))
par(mfrow=c(1,2), mar=c(4,3,1,1), cex=0.5)
plot(lambda, v1, type="l", lty=1, lwd=2, col="blue", xlab="mean")
plot(lambda, v2, type="l", lty=1, lwd=2, col="green", xlab="mean")
#box("outer")
``` 

## Simple Linear Regression for Twitter data?

The second problem is that the counts are probably not independent. 

* It is likely that a high tweet count has an impact on the next time period. 
* There are ways to deal with this (beyond the scope of this unit)

The third problem is nonlinear trends

* For example, exponential growth in counts?
* To some extent, transformation makes the trend in counts nonlinear
    * Log --- exponential
    * Sqrt --- quadratic
* This has limited use.
* Other methods are beyond the scope of this unit.

## Example of simple linear regression
Data collected by *ScraperWiki* (may be sampled?)

```{r, echo=FALSE, dev="pdf", fig.width=4, fig.height=2.5, fig.cap="Counts of #iPhone5 tweets for a period in 2013"}
df = data.frame( count = c(1042, 1409, 1325, 1189, 1229, 1277, 
427, 135, 145, 133, 102, 105, 108, 128, 144, 149, 130, 107, 106, 
83, 117, 123, 104, 116, 127, 75, 128, 136, 145, 120, 127, 110, 
109, 122, 136, 125, 143, 177, 142, 134, 153, 173, 151, 174, 168, 
158, 156, 128, 156, 140, 133, 132, 4), day = c(203, 204, 205, 
206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 
219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 
232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 
245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255))
par(mar=c(4,4,1,1), cex=0.7)
df2 = subset(df, day>209 & day<255)
plot(count~day, data=df2, pch=16)
#box("outer")
```

## Example of simple linear regression

```{r, echo=FALSE, dev="pdf", fig.width=4, fig.height=2.5, fig.cap="Square root Counts of #iPhone5 tweets for a period in 2013"}
par(mar=c(4,4,1,1), cex=0.7)
plot(sqrt(count)~day, data=df2, pch=16)
#box("outer")
```

## Example of simple linear regression

```{r echo=FALSE}
Xbar = mean(df2$day)
Ybar = mean(sqrt(df2$count))
SSX = sum((df2$day-Xbar)^2)
SSXY = with(df2, sum((day-Xbar)*(sqrt(count)-Ybar)))
bhat = SSXY/SSX
ahat = Ybar - bhat*Xbar
RSS = with(df2, sum((sqrt(count)- ahat - bhat*day)^2))
s2 = RSS/(nrow(df2)-2)
```

Results of simple linear regression of $\sqrt{count}$ against day. ($n= `r nrow(df2)`)

\begin{align*}
SS_X = `r SSX` && SS_{XY} = `r SSXY` \\
\hat{\beta} = `r bhat` && \hat{\alpha} = `r ahat` \\
RSS = `r RSS` && s^2 = `r s2`
\end{align*}

Is slope non-zero ($\beta\ne 0$)? 

$$t=\frac{\hat{\beta}}{s/\sqrt{SS_X}} = `r bhat/sqrt(s2/SSX)` \text{ and } t_{0.025, `r nrow(df2)-2`} = `r qt(0.975, nrow(df2)-2)`$$

so yes!

# Other methods for Trends --- Trend and Seasonality

## Twitter counts as a time series

If we are counting the number of tweets in a fixed time period, 
for a sequence of equally spaced times, this is an example of a __time series__ in statistics.

There are many models for time series data that allow for all the issues. (Normality, Independence, nonlinear trend)

Here we will look at a simple (descriptive) technique.

## Trend, Seasonal and Irregular components

The basic idea is that a time series can be broken down into 3 components.
$$ Y_t = T_t + S_t +\varepsilon_t$$
where

* $Y_t$ is the data
* $T_t$ is the (possibly nonlinear) trend. This represent the movement in the mean over time.
* $S_t$ is the seasonal component. (See below)
* $\varepsilon_t$ is the irregular or random component.

## Trend, Seasonal and Irregular components

The trend is a smooth component that varies slowly and represents how the mean value of the data changes over time.

The seasonal component consist of any periodic/cyclical behaviour in the data. For example, 
in temperature data, we expect certain months to be hotter than others in a systematic way.

If the seasonal cycle consists of $m$ time periods, (eg. $m=12$ for monthly weather data with an annual seasonal cycle), then we have two properties of the seasonal component. 

* $S_{t+m} = S_t$ --- the seasonal component is __periodic__
* $\sum_{t=1}^m S_t = 0$ --- the seasonal component over one cycle __sums to zero__ --- this means, the mean seasonal effect is zero.

## Trend, Seasonal and Irregular components

Other examples of _seasonal_ cycles are;

* An annual cycle in monthly recorded data --- temperatures, etc. ($m=12$)
* An annual cycle in quarterly data --- often used for sales data. ($m=4$)
* A weekly cycle in daily recorded data --- car traffic, share prices(?), ($m=7$)
* A daily cycle in hourly data --- emergency phone calls, traffic, ... ($m=24$)

The irregular component represents random variation not explained by trend and seasonal components. 
It has mean (expected value) zero.

## Moving Averages

One way to estimate the trend in the above _model_ is to use a moving average. 

A moving using a window of $k<n$ points takes an average over the first $k$ points, 
then moves one space and averages over the $k$ points.

```{r echo=FALSE, dev="pdf", fig.width=4, fig.height=2, fig.cap="3pt moving average"}
plot.new()
par(mar=rep(1,4))
plot.window(c(1,10), c(1.5,2.5))
yi = 2
for(i in 1:10) text(i, yi, bquote(x[.(i)]))
fun = function(x, col) {
  jit = 0.1*runif(1)
  rect(x-1.2, yi+jit-0.2, x+1.2, yi+jit+0.2, border=col, lwd=2)
  }
fun(2, "blue")
fun(3, "green")
fun(4, "cyan")
```

## Moving Averages

The central point of the window is then replaced by the moving average. 

In mathematical notation this can be written, for an odd sized window, say $k=2\times j + 1$
$$Z_t = \frac{1}{k} \sum_{i= -j}^j Y_{t+i} \qquad \forall \quad j < t \le n-j \qquad \text{undefined for other } t$$

For an even sized window $k = 2\times j$, we do not have an obvious central point so we make it an odd window, 
but use a half weight at the end points, so the sum of the weights is still $k$.

$$Z_t = \frac{1}{k} (\frac{1}{2} Y_{t-j} + \sum_{i= -j+1}^{j-1} Y_{t+i} + \frac{1}{2} Y_{t+j})
\qquad \forall \quad j < t \le n-j$$

## Moving Averages for Trend estimation

Since $\sum_{i=1}^m S_i =0$, if we take a moving average with window size $m$, we eliminate the seasonal component.

$$ Y_t = T_t + S_t +\varepsilon_t$$

So (for $m = 2j+1$ odd) 

$$ Z_t = \frac{1}{m} (\sum_{i= -j}^j Y_{t+i} = \sum_{i= -j}^j T_{t+i} + \sum_{i= -j}^j S_{t+i} + \sum_{i= -j}^j \varepsilon_{t+i})$$

And the middle term disappears since $S_{t+m} = S_t$ and $\sum_{i=1}^m S_i =0$

$Z_t$ is then taken as an _estimate_ of $T_t$. If $T_t$ is _smooth_ it will be a good estimate.

## IPhone5 hashtag
```{r, echo=FALSE, dev="pdf", fig.width=4, fig.height=2.5, fig.cap="Square root Counts of #iPhone5 tweets for a period in 2013"}
par(mar=c(4,4,1,1), cex=0.7)
plot(sqrt(count)~day, data=df2, pch=16)
#box("outer")
```

## IPhone5 hashtag

This data is counts on 45 consecutive days in the middle of 2013. 

If there is a seasonal component it is probably weekly, that is, $m=7$.

```{r echo=FALSE, dev="pdf", fig.width=4, fig.height=2.5, fig.cap="Trend for #iphone5 tweets"}
par(mar=c(4,4,1,1)+.1, cex=0.7)
Y = ts(sqrt(df2$count), freq=7)
plot(cbind(Y,T<-filter(Y, rep(1/7,7))), plot.type="single", col=c("blue", "green"), lwd=2, ylab=expression(sqrt(count)), xlab="week")
legend("bottomright", lty=1, col=c("blue", "green"), lwd=2, legend=c("Data", "Moving average trend m=7"))
```
 
## IPhone5 hashtag

For this data $Y_t$ the response is the __square root__ of counts of tweets at each day, starting at day 210, finishing at day 254.
So for a 7-point moving average we can start at day 213, and go up to day 251.

For example, the trend at day 213, is $$ (Y_{210}+Y_{211}+Y_{212}+Y_{213}+Y_{214}+Y_{215}+Y_{216})/7 $$

```{r echo=FALSE, results="asis"}
require(xtable, quietly=TRUE)
print(xtable(t(df2[1:7,c(2,1)]), digits=0),floating=FALSE, include.colnames=FALSE, comment=FALSE)
```

$$T_{213}= (`r paste(formatC(Y[1:7], digits=2, format="f"), collapse="+")`)/7 = `r round(sum(round(Y[1:7],2))/7,2)`$$

## Moving average with an Even window

If $m$ is even, we use the adjusted version, so that the moving average 
is over an odd number of points

$$ T_t =\frac{1}{m} (\frac{1}{2} Y_{t-j} + \sum_{i= -j+1}^{j-1} Y_{t+i} + \frac{1}{2} Y_{t+j})$$

For example, if $m=4$ in the above data, trend at day 213 becomes 

$$ (\frac{1}{2} Y_{211}+Y_{212}+Y_{213}+Y_{214}+\frac{1}{2}Y_{215})/4 $$

So the moving average is actually over 5 points, but the _weights_ add up to 4.


## Seasonal Component

The above has assumed a 7-day seasonal or period component. How do we estimate this component?

Simply, subtract the trend, then average over each time corresponding to the same part of the cycle.

$$\tilde{S}_t = \frac{1}{n_t} \sum_j (Y_{t+jm} - T_{t+jm})   \qquad \forall \quad t=1,\ldots,m$$  

where the sum is over all $j$ such that $t+jm$ is in the data, and $n_t$ is the number of terms that occur.

Unfortunately, these $\tilde{S}_t$ do not necessary __sum to zero__, which a seasonal component should do, so we subtract the mean, and set $$ S_t = \tilde{S}_t - \frac{1}{m} \sum_{j=1}^m \tilde{S}_j \qquad \forall \quad t=1,\ldots,m$$  

## Seasonal Component

One way to think about this is to configure the data as a table/matrix, with $m$ rows and $n/m$ columns, 
with _time_ running down each column.

The seasonal is the average along the rows after the trend is subtracted.

### Iphone5 hashtag

The data has $n=45$ data points and $m=7$ for a weekly cycle.

```{r echo=FALSE, results="asis"}
mmat = function(x, m, d=0) {
  tmp = c(x, rep(NA, m - length(x)%%m))
  print(xtable((M=matrix(tmp, nrow=m)), digits=d), floating=FALSE, include.colnames=FALSE, comment=FALSE)
  invisible(M)
}
mmat(df2$count,7)
```

## Iphone5 hashtag

We are using the square roots of the counts.

### Data
```{r echo=FALSE, results="asis"}
mmat(as.numeric(Y),7, 2)
```

## Iphone5 hashtag

Trend is a 7 point moving average

### Trend
```{r echo=FALSE, results="asis"}
mmat(as.numeric(T),7, 2)
```

## Iphone5 hashtag

### Difference
```{r echo=FALSE, results="asis"}
M=mmat(as.numeric(Y-T),7, 2)
```

## Iphone5 hashtag

$\tilde{S}_t$
```{r echo=FALSE, results="asis"}
St = apply(M,1,mean,na.rm=TRUE)
print(xtable(matrix(St,nrow=1), digits=3),floating=FALSE, include.rownames=FALSE, comment=FALSE)
```

$S_t =  \tilde{S}_t - \frac{1}{m} \sum_{j=1}^m \tilde{S}_j$
```{r echo=FALSE, results="asis"}
St = St - mean(St)
print(xtable(matrix(St,nrow=1), digits=3),floating=FALSE, include.rownames=FALSE, comment=FALSE)
```


### Irregular component 

The irregular component is simply everything that is left over.

$$ Y_t - T_t - S_t$$ 

## Iphone5 hashtag

```{r, echo=FALSE, dev="pdf", fig.width=4, fig.height=2.5, fig.cap="Seasonal component for iphone5 hashtag"}
par(mar=c(4,4,1,1), cex=0.7)
plot(St, type="b", xlab="day", ylab="Seasonal")
text(1,-0.7, "Day 1 is actually Tuesday", pos=4)
#box("outer")
``` 

## Summary

So in this lecture we looked at

* Twitter's method for finding _Twitter Trends_
* Revised _Simple Linear Regression_ as a simple way to look at trends
* Saw how moving averages can be used to estimate trends and seasonality 
     * We will look at how to do this in R in the lab.

Next time, _Events_





